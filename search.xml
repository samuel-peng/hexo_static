<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Word Ladder</title>
      <link href="/blog/2018/07/07/word-ladder/"/>
      <url>/blog/2018/07/07/word-ladder/</url>
      <content type="html"><![CDATA[<p>You know it, the classic word ladder problem. It turns out to be part 1 of my second assignment at <span style="color: red; font-weight: bold;">Stanford&nbsp;University</span>.<br>For those of you who don’t know about word ladder (I doubt there is any), here’s a condensed version of the problem description.</p><blockquote><p><code>Input</code>: a dictionary file and two words.<br><code>Objective</code>: find a path to go from the first word to the second, by changing one letter each time.<br><code>Output</code>: the path from word 1 to word two.</p></blockquote><p>Simple enough. However, the problem requires the program <em>not</em> to use <strong>recursion</strong> but use <strong>BFS</strong> to accomplish such task.</p><p>It’s a fairly easy problem, and the pseudocode was even given to us:</p><blockquote><p>to find a path from word 1 to word 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;create a queue of stacks, initially containing only a single stack storing {word 1}.<br>&nbsp;&nbsp;&nbsp;&nbsp;loop until queue is empty (can’t find the path) or word 2 is found:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dequeue a stack s.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each valid unused English word w that differs by 1 letter of the word on top of s<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create a new stack s2 whose contents are s + w added on top<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add s2 to the queue</p></blockquote><p>However, there is a pretty serious issue to consider with this problem, and that is the size of the dictionary. The dictionary file contains nearly .27 million words in it. Although efficient data types will be used to handle them, the fact that there are so many possible “next words” for each word is frightening. The queue that stores the stacks builds up too quickly that the memory it needs can’t be ignored.<br>With only a 5-letter word example that should take merely 9 steps to finish, I get an error message:</p><p><code>A C++ exception occurred during program execution:<br>std::bad_alloc<br><br>Stack trace:<br>vector.h         Vector::operator=(Vector const&amp;)<br>queue.h          Queue::expandRingBufferCapacity()<br>queue.h          Queue::enqueue(Stack const&amp;)<br>wordladder.cpp   game(Set const&amp;, string, string)<br>wordladder.cpp   interact()<br>wordladder.cpp   main()<br></code></p><p>It appears that while trying to expand <code>RingBufferCapacity</code>, the memory decided that there’s not enough usable memory to allocate for my program, therefore it shut down.</p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> BFS </tag>
            
            <tag> Classic </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
