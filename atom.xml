<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Samuel Peng</title>
  
  <subtitle>Programming Log</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://samuelpeng.com/blog/"/>
  <updated>2018-07-08T21:31:56.361Z</updated>
  <id>http://samuelpeng.com/blog/</id>
  
  <author>
    <name>Samuel Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Word Ladder</title>
    <link href="http://samuelpeng.com/blog/2018/07/07/word-ladder/"/>
    <id>http://samuelpeng.com/blog/2018/07/07/word-ladder/</id>
    <published>2018-07-07T10:10:20.000Z</published>
    <updated>2018-07-08T21:31:56.361Z</updated>
    
    <content type="html"><![CDATA[<p>You know it, the classic word ladder problem. It turns out to be part 1 of my second assignment at <span style="color: red; font-weight: bold;">Stanford&nbsp;University</span>.<br>For those of you who don’t know about word ladder (I doubt there is any), here’s a condensed version of the problem description.</p><blockquote><p><code>Input</code>: a dictionary file and two words.<br><code>Objective</code>: find a path to go from the first word to the second, by changing one letter each time.<br><code>Output</code>: the path from word 1 to word two.</p></blockquote><p>Simple enough. However, the problem requires the program <em>not</em> to use <strong>recursion</strong> but use <strong>BFS</strong> to accomplish such task.<br>It’s a fairly easy problem, and the pseudocode was even given to us:</p><blockquote><p>to find a path from word 1 to word 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;create a queue of stacks, initially containing only a single stack storing {word 1}.<br>&nbsp;&nbsp;&nbsp;&nbsp;loop until queue is empty (can’t find the path) or word 2 is found:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dequeue a stack s.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each valid unused English word w that differs by 1 letter of the word on top of s<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create a new stack s2 whose contents are s + w added on top<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add s2 to the queue</p></blockquote><p>However, there is a pretty serious issue to consider with this problem, and that is the size of the dictionary. The dictionary file contains nearly .27 million words in it. Although efficient data types will be used to handle them, the fact that there are so many possible “next words” for each word is frightening. The queue that stores the stacks builds up too quickly that the memory it needs can’t be ignored.<br>With only a 5-letter word example that should take merely 9 steps to finish, I get an error message:</p><p><code>A C++ exception occurred during program execution:<br>std::bad_alloc<br><br>Stack trace:<br>vector.h         Vector::operator=(Vector const&amp;)<br>queue.h          Queue::expandRingBufferCapacity()<br>queue.h          Queue::enqueue(Stack const&amp;)<br>wordladder.cpp   game(Set const&amp;, string, string)<br>wordladder.cpp   interact()<br>wordladder.cpp   main()<br></code></p><p>It appears that while trying to expand <code>RingBufferCapacity</code>, the memory decided that there’s not enough usable memory to allocate for my program, therefore it shut down.<br>Instead of blaming my computer, which is not crappy at all considering the fact that it has 16 GB of memory, for not having enough memory to run this program, I decided to look into the codes and see if there’s any way to optimize it so that it won’t ask for that much memory.</p><p>It’s not so hard to realize that taking a humongous amount of memory is one of the characteristics of the BFS algorithm. Then the problem comes to how to alter the BFS algorithm to make it cost less memory, and one of the basic ways to optimize BFS is: <strong><em>bidirectional BFS</em></strong>.</p><p>With that name, it’s pretty obvious how it works. BFS from both sides. When the two words are given, the program use BFS to search from both the word 1 side and the word 2 side, level by level. When they find a word in common, the shortest path has been found. You can try to visually imagine how much memory and time this is going to save, and it <strong>does</strong> save both significantly.</p><p>However, with the implementation of bidirectional BFS, another problem emerges: the case when no word ladder can be found.</p><p>I guess it’s also not hard to imagine. Previously, a huge queue of stacks will be generated, and when it becomes empty, it shows that no path can be found between these two words. With bidirectional BFS, two huge queues of stacks will be generated to determine if there is a path between the given words.</p><p>To be continued…</p><details><summary>See the code here</summary><br><p><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//contents to be added</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></p><br></details>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;You know it, the classic word ladder problem. It turns out to be part 1 of my second assignment at &lt;span style=&quot;color: red; font-weight: 
      
    
    </summary>
    
      <category term="Programming" scheme="http://samuelpeng.com/blog/categories/Programming/"/>
    
    
      <category term="C++" scheme="http://samuelpeng.com/blog/tags/C/"/>
    
      <category term="BFS" scheme="http://samuelpeng.com/blog/tags/BFS/"/>
    
      <category term="Classic" scheme="http://samuelpeng.com/blog/tags/Classic/"/>
    
      <category term="Stanford" scheme="http://samuelpeng.com/blog/tags/Stanford/"/>
    
  </entry>
  
</feed>
