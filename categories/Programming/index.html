<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Category: Programming | Samuel Peng</title>
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/blog/favicon.ico">
  <link rel="alternate" href="/blog/atom.xml" title="Samuel Peng">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Samuel Peng">
<meta property="og:url" content="http://samuelpeng.com/blog/categories/Programming/index.html">
<meta property="og:site_name" content="Samuel Peng">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Samuel Peng">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/blog/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/blog/' >
				Samuel Peng
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/blog/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/blog/archives'>
								Archives
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-gallery' href='https://instagram.com/samueljpeng/'>
								Gallery
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-about' href='/blog/about'>
								About
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-main' href='http://samuelpeng.com/'>
								samuelpeng.com
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon icon-search"></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search flat-box"></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/blog/" class="nav-home nav">
				Home
			</a>
		
			<a href="/blog/archives" class="nav-archives nav">
				Archives
			</a>
		
			<a href="https://instagram.com/samueljpeng/" class="nav-gallery nav">
				Gallery
			</a>
		
			<a href="/blog/about" class="nav-about nav">
				About
			</a>
		
			<a href="http://samuelpeng.com/" class="nav-main nav">
				samuelpeng.com
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        
  <script>
    window.subData= { title:'Category : Programming'}
  </script>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/blog/2018/07/08/word-ladder/">
        Word Ladder
      </a>
    </h2>
    
    <time>
      Jul 7, 2018
    </time>
		
    
    <div class='cats'>
        <a href="/blog/categories/Programming/">Programming</a>
    </div>

  </section>
  <section class="article typo">
	  <p>You know it, the classic word ladder problem. It turns out to be part 1 of my second assignment at <span style="color: red; font-weight: bold;">Stanford&nbsp;University</span>.<br>For those of you who don’t know about word ladder (I doubt there is any), here’s a condensed version of the problem description.</p>
<blockquote>
<p><code>Input</code>: a dictionary file and two words.<br><code>Objective</code>: find a path to go from the first word to the second, by changing one letter each time.<br><code>Output</code>: the path from word 1 to word two.</p>
</blockquote>
<p>Simple enough. However, the problem requires the program <em>not</em> to use <strong>recursion</strong> but use <strong>BFS</strong> to accomplish such task.<br>It’s a fairly easy problem, and the pseudocode was even given to us:</p>
<blockquote>
<p>to find a path from word 1 to word 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;create a queue of stacks, initially containing only a single stack storing {word 1}.<br>&nbsp;&nbsp;&nbsp;&nbsp;loop until queue is empty (can’t find the path) or word 2 is found:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dequeue a stack s.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each valid unused English word w that differs by 1 letter of the word on top of s<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create a new stack s2 whose contents are s + w added on top<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add s2 to the queue</p>
</blockquote>
<p>However, there is a pretty serious issue to consider with this problem, and that is the size of the dictionary. The dictionary file contains nearly .27 million words in it. Although efficient data types will be used to handle them, the fact that there are so many possible “next words” for each word is frightening. The queue that stores the stacks builds up too quickly that the memory it needs can’t be ignored.</p>
<p>With only a 5-letter word example that should take merely 9 steps to finish, I get an error message:</p>
<p><code>A C++ exception occurred during program execution:<br>std::bad_alloc<br><br>Stack trace:<br>vector.h         Vector::operator=(Vector const&amp;)<br>queue.h          Queue::expandRingBufferCapacity()<br>queue.h          Queue::enqueue(Stack const&amp;)<br>wordladder.cpp   game(Set const&amp;, string, string)<br>wordladder.cpp   interact()<br>wordladder.cpp   main()<br></code></p>
<p>It appears that while trying to expand <code>RingBufferCapacity</code>, the memory decided that there’s not enough usable memory to allocate for my program, therefore it shut down.<br>Instead of blaming my computer, which is not crappy at all considering the fact that it has 16 GB of memory, for not having enough memory to run this program, I decided to look into the codes and see if there’s any way to optimize it so that it won’t ask for that much memory.</p>
<p>It’s not so hard to realize that taking a humongous amount of memory is one of the characteristics of the BFS algorithm. Then the problem comes to how to alter the BFS algorithm to make it cost less memory, and one of the basic ways to optimize BFS is: <strong><em>bidirectional BFS</em></strong>.</p>
<p>With that name, it’s pretty obvious how it works. BFS from both sides. When the two words are given, the program use BFS to search from both the word 1 side and the word 2 side, level by level. When they find a word in common, the shortest path has been found. You can try to visually imagine how much memory and time this is going to save, and it <strong>does</strong> save both significantly.</p>
<p>However, with the implementation of bidirectional BFS, another problem emerges: the case when no word ladder can be found. I guess it’s also not hard to imagine. Previously, a huge queue of stacks will be generated, and when it becomes empty, it shows that no path can be found between these two words. With bidirectional BFS, two huge queues of stacks will be generated to determine if there is a path between the given words.</p>
<p>Just as I felt so desperate that I couldn’t find a solution for it, I realized why not utilize DFS(Depth-First Search). So, I wrote a new bool funtion called ‘exist()’ using DFS to see if there is a path between the two given words. Since we only care about if there <strong>is</strong> a path, DFS does the job. Although it might have found the not-shortest path, but that’s not the path we’ll be outputing, since our bidirectional BFS function is the function that’ll tell us the shortest path between the two words, if any.</p>
<p>With DFS + Bidirectional BFS, the program now runs swiftly fast. What previously takes more than 20 seconds can now be solved in about a second.</p>
<p>Woo-Hoo! Problem solved! </p>
<hr>
<p>The code is attached down below, however, <span style="color:red;"><strong>Stanford Honor Code</strong></span> does strictly forbid looking at others’ codes. If this is your homework problem, now you know my approach. Try write it out yourself! If you can’t figure it out, go to office hours! Just <strong>DO <span style="color:red;">NOT</span> LOOK AT THE CODE</strong> if you’re taking the class.</p>
<p>Cheers~</p>
<details><summary>See the code here</summary><br><p><br><code>`cpp
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &quot;filelib.h&quot;
#include &quot;set.h&quot;
#include &quot;queue.h&quot;
#include &quot;stack.h&quot;
#include &quot;simpio.h&quot;
#include &quot;console.h&quot;
using namespace std;

void welcomePrint();
//Printing the welcome information

bool lengthCheck(const string &amp;from, const string &amp;to);
//return true if the two given words are not of the same length

bool dictCheck(const Set&lt;string&gt; &amp;dict, const string &amp;from, const string &amp;to);
//return true if either or both words don&#39;t exist in the dictionary

bool wordCheck(const string &amp;from, const string &amp;to);
//return true if both words are the same

bool exist(const Set&lt;string&gt; &amp;dic, const string &amp;from, const string &amp;to);
//Uses DFS to determine if a valid ladder exists
//return true if a ladder exist from word 1 to word 2

void generateLadder(Queue&lt;Stack&lt;string&gt;&gt; &amp;revSolve, Stack&lt;string&gt; &amp;cur, const string &amp;midWord, string &amp;ladder, bool side);
//Generate the string &#39;ladder&#39; to print out

void BFS(const Set&lt;string&gt; &amp;dictionary, Queue&lt;Stack&lt;string&gt;&gt; &amp;solve, Queue&lt;Stack&lt;string&gt;&gt; &amp;rSolve, Set&lt;string&gt; &amp;level, string &amp;ladder, bool side);
//Breadth-First Search function of the given side

string game(const Set&lt;string&gt; &amp;dic, const string &amp;from, const string &amp;to);
//The function that does the main calculations

void interact();
//for interaction. Takes in inputs, calls the calculation function.

int main() {

    welcomePrint();

    interact();

    cout &lt;&lt; &quot;Have a nice day.&quot; &lt;&lt; endl;
    return 0;
}

void welcomePrint() {
    cout &lt;&lt; &quot;Welcome to CS 106B/X Word Ladder!&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;Please give me two English words, and I will convert the&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;first into the second by modifying one letter at a time.&quot; &lt;&lt; endl &lt;&lt; endl;
}

bool lengthCheck(const string &amp;from, const string &amp;to) {
    return from.length() != to.length();
}

bool dictCheck(const Set&lt;string&gt; &amp;dict, const string &amp;from, const string &amp;to) {
    return !(dict.contains(from) &amp;&amp; dict.contains(to));
}

bool wordCheck(const string &amp;from, const string &amp;to) {
    return from == to;
}

bool exist(const Set&lt;string&gt; &amp;dic, const string &amp;from, const string &amp;to) {
    //Use DFS to search if path exists

    Stack&lt;string&gt; tracking = {from}; //Stack of DFS process
    Set&lt;string&gt; trackMember = {from}; //All visited members

    Stack&lt;int&gt; index = {0};
    //indicating which letter of the word to change &amp; to what letter
    //index / 26 = loc @ word; index % 26 = letter in alphabet;

    while(!tracking.isEmpty()){
        string lastWord = tracking.peek();
        if(index.peek() &lt; lastWord.length() * 26) {
            string newWord = lastWord;
            newWord.replace(index.peek() / 26, 1, 1, char(index.peek() % 26 + 97));
            if(newWord == to) return true; //found target word. ladder exists.
            if(dic.contains(newWord) &amp;&amp; !trackMember.contains(newWord)){
                //valid nextWord. Push into stack
                //move one level deeper.
                tracking.push(newWord);
                trackMember.add(newWord);
                index.push(0);
            } else {
                //invalid nextWord
                //move on to the next possible nextWord
                index.push(index.pop() + 1);
            }
        } else {
            //all possible nextwords is visited.
            //move back to the previous word in stack.
            index.pop();
            tracking.pop();
        }
    }

    return false;
}

void generateLadder(Queue&lt;Stack&lt;string&gt;&gt; &amp;revSolve, Stack&lt;string&gt; &amp;cur, const string &amp;midWord, string &amp;ladder, bool side) {
    if (side) {
        //Ladder found with solveFront &amp; toLevel

        //Add the front part (word 1 side) to &#39;ladder&#39;
        for(string path : cur) {
            ladder += path;
            ladder += &quot; &quot;;
        }

        //Add the second part (word 2 side) to &#39;ladder&#39;
        for(Stack&lt;string&gt; item : revSolve) {
            if(item.peek() == midWord) {
                Stack&lt;string&gt; reverse;
                int stackSize = item.size();
                for (int loc = 0 ; loc &lt; stackSize ; loc++) {
                    reverse.push(item.pop());
                }
                for (string str : reverse) {
                    ladder += str;
                    ladder += &quot; &quot;;
                }
                break;
            }
        }
    } else {
        //Ladder found with solveTo &amp; fromLevel

        //Add the front part (word 1 side) to &#39;ladder&#39;
        for(Stack&lt;string&gt; item : revSolve) {
            if(item.peek() == midWord) {
                for (string str : item) {
                    ladder += str;
                    ladder += &quot; &quot;;
                }
                break;
            }
        }

        //Generate the string for the second part (word 2 side)
        string halfResult;
        for(string path : cur) {
            halfResult = path + &quot; &quot; + halfResult;
        }

        ladder += halfResult;//Combine two parts to &#39;ladder&#39;
    }
}

void BFS(const Set&lt;string&gt; &amp;dictionary, Queue&lt;Stack&lt;string&gt;&gt; &amp;solve, Queue&lt;Stack&lt;string&gt;&gt; &amp;rSolve, Set&lt;string&gt; &amp;level, string &amp;ladder, bool side) {
    int qSize = solve.size(); //Size of the Queue

    for(int i = 0 ; i &lt; qSize ; i++) { //Loop through the Queue
        Stack&lt;string&gt; current = solve.dequeue(); //Get item from Queue
        string lastWord = current.peek(); //Peek the top word of the current Stack
        Set&lt;string&gt; cont = {}; //To store words already contained in the Stack
        int cSize = current.size(); //size of the current Stack

        //Add all the items of the Stack to the Set &#39;cont&#39;
        for(int t = 0 ; t &lt; cSize ; t++) {
            string temp = current.pop();
            cont.add(temp);
            current.push(temp);
        }

        //Listing all possible &#39;nextWords&#39;
        for(int c = 0 ; c &lt; lastWord.length() ; c++) {
            for(int a = 97 ; a &lt; 123 ; a++) {
                string newWord = lastWord;
                newWord.replace(c, 1, 1, char(a));
                //replacing the c-th character of the word to char(a) (by ascii)

                if(dictionary.contains(newWord) &amp;&amp; !cont.contains(newWord)) {
                    //new word is a valid word
                    if (level.contains(newWord)) {
                        //shortest ladder found
                        generateLadder(rSolve, current, newWord, ladder, side);
                        return;
                    }
                    current.push(newWord); //Add the valid word to the current stack
                    solve.enqueue(current); //Add the stack back into the back of the queue
                    current.pop(); //Remove the word from the stack
                }
            }
        }
    }
}

string game(const Set&lt;string&gt; &amp;dic, const string &amp;from, const string &amp;to) {

    Queue&lt;Stack&lt;string&gt;&gt; solveFrom; //Stores the information for the word 1 side
    Queue&lt;Stack&lt;string&gt;&gt; solveTo; //Stores the information for the word 2 side
    Set&lt;string&gt; fromLevel = {to}, toLevel = {from}; //Stores the words visited by each side
    string ladder = &quot;&quot;; //The result string to return

    solveFrom.add({to}); //Initialize
    solveTo.add({from}); //Initialize

    while(!solveFrom.isEmpty() &amp;&amp; !solveTo.isEmpty()){

        //Search from word 1 side
        BFS(dic, solveFrom, solveTo, toLevel, ladder, true);
        if(ladder != &quot;&quot;) return ladder; //Ladder found

        //Update word 1 side visited-word pool
        for(Stack&lt;string&gt; item : solveFrom) {
            fromLevel.add(item.peek());
        }

        //Search from word 2 side
        BFS(dic, solveTo, solveFrom, fromLevel, ladder, false);
        if(ladder != &quot;&quot;) return ladder; //Ladder found

        //Update word 2 side visited-word pool
        for(Stack&lt;string&gt; item : solveTo) {
            toLevel.add(item.peek());
        }
    }
    return &quot;NA&quot;;
}

void interact() {
    ifstream infile;
    promptUserForFile(infile, &quot;Dictionary file name: &quot;);

    Set&lt;string&gt; dict;

    string dictWord;
    while(getline(infile, dictWord)) {
        dict.add(dictWord);
    }

    infile.close();
    while (1) {
        string fromWord, toWord;
        cout &lt;&lt; endl;

        fromWord = getLine(&quot;Word 1 (or Enter to quit): &quot;);
        if (fromWord == &quot;&quot;) break;
        transform(fromWord.begin(), fromWord.end(), fromWord.begin(), ::tolower);

        toWord = getLine(&quot;Word 2 (or Enter to quit): &quot;);
        if (toWord == &quot;&quot;) break;
        transform(toWord.begin(), toWord.end(), toWord.begin(), ::tolower);

        if(lengthCheck(fromWord, toWord)) {
            cout &lt;&lt; &quot;The two words must be the same length.&quot; &lt;&lt; endl;
            continue;
        } else if (dictCheck(dict, fromWord, toWord)) {
            cout &lt;&lt; &quot;The two words must be found in the dictionary.&quot; &lt;&lt; endl;
            continue;
        } else if (wordCheck(fromWord, toWord)) {
            cout &lt;&lt; &quot;The two words must be different.&quot; &lt;&lt; endl;
            continue;
        } else {
            if (!exist(dict, fromWord, toWord)) {
                cout &lt;&lt; &quot;No word ladder found from &quot; &lt;&lt; toWord &lt;&lt; &quot; back to &quot; &lt;&lt; fromWord &lt;&lt; &quot;.&quot; &lt;&lt; endl;
            } else {
                cout &lt;&lt; &quot;A ladder from &quot; &lt;&lt; toWord &lt;&lt; &quot; back to &quot; &lt;&lt; fromWord &lt;&lt; &quot;:&quot; &lt;&lt; endl;
                cout &lt;&lt; game(dict, fromWord, toWord) &lt;&lt; endl;
            }
        }
    }
}</code><br></p><br></details>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/blog/tags/C/">C++</a>
      
        <a href="/blog/tags/BFS/">BFS</a>
      
        <a href="/blog/tags/Classic/">Classic</a>
      
        <a href="/blog/tags/Stanford/">Stanford</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
</section>


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/blog/avatar.jpg' />

<div class='header'>Samuel Peng</div>
<div class='content'>
<div class='desc'>This is my life. I will live it the way I like.</div>
</div>
</section>


  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="http://joelsparksmusic.com/">
            <div class='name'>Joel Sparks</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="http://commoc.co/">
            <div class='name'>Commoc Official</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/blog/categories/Programming/"><div class='name'>Programming</div><div class='badget'>1</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/blog/tags/BFS/" style="font-size: 14px; color: #808080">BFS</a> <a href="/blog/tags/C/" style="font-size: 14px; color: #808080">C++</a> <a href="/blog/tags/Classic/" style="font-size: 14px; color: #808080">Classic</a> <a href="/blog/tags/Stanford/" style="font-size: 14px; color: #808080">Stanford</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/samuel-peng" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/samueljpeng" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://facebook.com/samuel.joel.peng" class="social facebook"
          target="_blank" rel="external">
          <span class="icon icon-facebook"></span>
        </a>
      
        <a href="mailto:samuelpeng1@gmail.com" class="social mail"
          target="_blank" rel="external">
          <span class="icon icon-mail"></span>
        </a>
      
    
  </div>
  
  <div>Theme <a href='https://github.com/stkevintan/hexo-theme-material-flow' class="codename">MaterialFlow</a> designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.</div>
  
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<script src="/blog/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/blog/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/blog/js/search.js"></script>
<script src="/blog/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
