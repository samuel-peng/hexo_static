{"meta":{"title":"Samuel Peng","subtitle":"Programming Log","description":null,"author":"Samuel Peng","url":"http://samuelpeng.com/blog"},"pages":[{"title":"About Me","date":"2018-07-07T07:54:46.000Z","updated":"2018-07-07T04:57:58.327Z","comments":true,"path":"about/index.html","permalink":"http://samuelpeng.com/blog/about/index.html","excerpt":"","text":"I’m Samuel Peng, and I am a…Programmer.I am interested in &amp; work with: C++ Swift JavaScript Python Java I’ve been involved in: Hackathons iOS Development Web Development More… Singer-SongwriterVisit my website @ joelsparksmusic.com to learn more about the music I make. Neflix LoverI love watching… Grey’s Anatomy Scandal Criminal Minds Person of Interest Sherlock House of Cards … Contact me? Telegram: @sjpeng GitHub: samuel-peng Twitter: @samueljpeng Email: samuelpeng1@gmail.com"}],"posts":[{"title":"Word Ladder","slug":"word-ladder","date":"2018-07-08T00:10:20.000Z","updated":"2018-07-09T21:19:16.647Z","comments":true,"path":"2018/07/08/word-ladder/","link":"","permalink":"http://samuelpeng.com/blog/2018/07/08/word-ladder/","excerpt":"","text":"You know it, the classic word ladder problem. It turns out to be part 1 of my second assignment at Stanford&nbsp;University.For those of you who don’t know about word ladder (I doubt there is any), here’s a condensed version of the problem description. Input: a dictionary file and two words.Objective: find a path to go from the first word to the second, by changing one letter each time.Output: the path from word 1 to word two. Simple enough. However, the problem requires the program not to use recursion but use BFS to accomplish such task.It’s a fairly easy problem, and the pseudocode was even given to us: to find a path from word 1 to word 2:&nbsp;&nbsp;&nbsp;&nbsp;create a queue of stacks, initially containing only a single stack storing {word 1}.&nbsp;&nbsp;&nbsp;&nbsp;loop until queue is empty (can’t find the path) or word 2 is found:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dequeue a stack s.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each valid unused English word w that differs by 1 letter of the word on top of s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create a new stack s2 whose contents are s + w added on top&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add s2 to the queue However, there is a pretty serious issue to consider with this problem, and that is the size of the dictionary. The dictionary file contains nearly .27 million words in it. Although efficient data types will be used to handle them, the fact that there are so many possible “next words” for each word is frightening. The queue that stores the stacks builds up too quickly that the memory it needs can’t be ignored. With only a 5-letter word example that should take merely 9 steps to finish, I get an error message: A C++ exception occurred during program execution:std::bad_allocStack trace:vector.h Vector::operator=(Vector const&amp;)queue.h Queue::expandRingBufferCapacity()queue.h Queue::enqueue(Stack const&amp;)wordladder.cpp game(Set const&amp;, string, string)wordladder.cpp interact()wordladder.cpp main() It appears that while trying to expand RingBufferCapacity, the memory decided that there’s not enough usable memory to allocate for my program, therefore it shut down. Instead of blaming my computer, which is not crappy at all considering the fact that it has 16 GB of memory, for not having enough memory to run this program, I decided to look into the codes and see if there’s any way to optimize it so that it won’t ask for that much memory. It’s not so hard to realize that taking a humongous amount of memory is one of the characteristics of the BFS algorithm. Then the problem comes to how to alter the BFS algorithm to make it cost less memory, and two of the basic ways to optimize BFS are: tracking visited nodes and bidirectional BFS. For bidirectional BFS, its method is pretty obvious considering it has a straightforward name. BFS from both sides. When the two words are given, the program use BFS to search from both the word 1 side and the word 2 side, level by level. When they find a word in common, the shortest path has been found. You can try to visually imagine how much memory and time this is going to save, and it does save both significantly. For tracking visited node, it’s also simple enough. Create a Set to store all the visited words, and add the word into the Set each time when a new &amp; valid word is generated and about to be pushed into the queue. Woo-Hoo! Problem solved! The code is attached down below, however, Stanford Honor Code does strictly forbid looking at others’ codes. If this is your homework problem, now you know my approach. Try write it out yourself! If you can’t figure it out, go to office hours! Just DO NOT LOOK AT THE CODE if you’re taking the class. Cheers~ See the code here123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;algorithm&gt;#include \"filelib.h\"#include \"set.h\"#include \"queue.h\"#include \"stack.h\"#include \"simpio.h\"#include \"console.h\"using namespace std;void welcomePrint();//Printing the welcome informationbool dictCheck(const Set&lt;string&gt; &amp;dict, const string &amp;from, const string &amp;to);//return true if either or both words is more than one step from dictionary wordbool wordCheck(const string &amp;from, const string &amp;to);//return true if both words are the samevoid generateLadder(Queue&lt;Stack&lt;string&gt;&gt; &amp;revSolve, Stack&lt;string&gt; &amp;cur, const string &amp;midWord, string &amp;ladder, bool side);//Generate the string 'ladder' to print outvoid BFS(const Set&lt;string&gt; &amp;dictionary, Queue&lt;Stack&lt;string&gt;&gt; &amp;solve, Queue&lt;Stack&lt;string&gt;&gt; &amp;rSolve, Set&lt;string&gt; &amp;level, string &amp;ladder, bool side);//Breadth-First Search function of the given sidestring game(const Set&lt;string&gt; &amp;dic, const string &amp;from, const string &amp;to);//The function that does the main calculationsvoid interact();//for interaction. Takes in inputs, calls the calculation function.int main() &#123; welcomePrint(); interact(); cout &lt;&lt; \"Have a nice day.\" &lt;&lt; endl; return 0;&#125;void welcomePrint() &#123; cout &lt;&lt; \"Welcome to CS 106B/X Word Ladder!\" &lt;&lt; endl; cout &lt;&lt; \"Please give me two English words, and I will convert the\" &lt;&lt; endl; cout &lt;&lt; \"first into the second by modifying one letter at a time.\" &lt;&lt; endl &lt;&lt; endl;&#125;bool oneStep(const Set&lt;string&gt; &amp;dic, const string &amp;str) &#123; //Listing all possible 'nextWords' for(int c = 0 ; c &lt; str.length() ; c++) &#123; for(int a = 97 ; a &lt; 123 ; a++) &#123; string newWord = str; newWord.replace(c, 1, 1, char(a)); //replacing the c-th character of the word to char(a) (by ascii) if(dic.contains(newWord)) return true; &#125; &#125; //Consider inserting a letter legal. for(int c = 0 ; c &lt;= str.length() ; c++) &#123; for(int a = 97 ; a &lt; 123 ; a++) &#123; string newWord = str; newWord.insert(c, 1, char(a)); //inserting at the c-th character of the word, char(a) (by ascii) if(dic.contains(newWord)) return true; &#125; &#125; //Consider deleting a letter legal. for(int c = 0 ; c &lt; str.length() ; c++) &#123; string newWord = str; newWord.erase(c, 1); //deleting the c-th character of the word if(dic.contains(newWord)) return true; &#125; return false;&#125;bool dictCheck(const Set&lt;string&gt; &amp;dict, const string &amp;from, const string &amp;to) &#123; return !((oneStep(dict, from) || dict.contains(from)) &amp;&amp; (oneStep(dict, to) || dict.contains(to)));&#125;bool wordCheck(const string &amp;from, const string &amp;to) &#123; return from == to;&#125;void generateLadder(Queue&lt;Stack&lt;string&gt;&gt; &amp;revSolve, Stack&lt;string&gt; &amp;cur, const string &amp;midWord, string &amp;ladder, bool side) &#123; if (side) &#123; //Ladder found with solveFront &amp; toLevel //Add the front part (word 1 side) to 'ladder' for(string path : cur) &#123; ladder += path; ladder += \" \"; &#125; //Add the second part (word 2 side) to 'ladder' for(Stack&lt;string&gt; item : revSolve) &#123; if(item.peek() == midWord) &#123; Stack&lt;string&gt; reverse; int stackSize = item.size(); for (int loc = 0 ; loc &lt; stackSize ; loc++) &#123; reverse.push(item.pop()); &#125; for (string str : reverse) &#123; ladder += str; ladder += \" \"; &#125; break; &#125; &#125; &#125; else &#123; //Ladder found with solveTo &amp; fromLevel //Add the front part (word 1 side) to 'ladder' for(Stack&lt;string&gt; item : revSolve) &#123; if(item.peek() == midWord) &#123; for (string str : item) &#123; ladder += str; ladder += \" \"; &#125; break; &#125; &#125; //Generate the string for the second part (word 2 side) string halfResult; for(string path : cur) &#123; halfResult = path + \" \" + halfResult; &#125; ladder += halfResult;//Combine two parts to 'ladder' &#125;&#125;void BFS(const Set&lt;string&gt; &amp;dictionary, Queue&lt;Stack&lt;string&gt;&gt; &amp;solve, Queue&lt;Stack&lt;string&gt;&gt; &amp;rSolve, Set&lt;string&gt; &amp;myLevel, Set&lt;string&gt; &amp;level, string &amp;ladder, bool side) &#123; Stack&lt;string&gt; current = solve.dequeue(); //Get item from Queue string lastWord = current.peek(); //Peek the top word of the current Stack //Listing all possible 'nextWords' for(int c = 0 ; c &lt; lastWord.length() ; c++) &#123; for(int a = 97 ; a &lt; 123 ; a++) &#123; string newWord = lastWord; newWord.replace(c, 1, 1, char(a)); //replacing the c-th character of the word to char(a) (by ascii) if(dictionary.contains(newWord) &amp;&amp; !myLevel.contains(newWord)) &#123; //new word is a valid word if (level.contains(newWord)) &#123; //shortest ladder found generateLadder(rSolve, current, newWord, ladder, side); return; &#125; current.push(newWord); //Add the valid word to the current stack myLevel.add(newWord); //Add the valid word to 'visited' set solve.enqueue(current); //Add the stack back into the back of the queue current.pop(); //Remove the word from the stack &#125; &#125; &#125; //Consider inserting a letter legal. for(int c = 0 ; c &lt;= lastWord.length() ; c++) &#123; for(int a = 97 ; a &lt; 123 ; a++) &#123; string newWord = lastWord; newWord.insert(c, 1, char(a)); //inserting at the c-th character of the word, char(a) (by ascii) if(dictionary.contains(newWord) &amp;&amp; !myLevel.contains(newWord)) &#123; //new word is a valid word if (level.contains(newWord)) &#123; //shortest ladder found generateLadder(rSolve, current, newWord, ladder, side); return; &#125; current.push(newWord); //Add the valid word to the current stack solve.enqueue(current); //Add the stack back into the back of the queue current.pop(); //Remove the word from the stack &#125; &#125; &#125; //Consider deleting a letter legal. for(int c = 0 ; c &lt; lastWord.length() ; c++) &#123; string newWord = lastWord; newWord.erase(c, 1); //deleting the c-th character of the word if(dictionary.contains(newWord) &amp;&amp; !myLevel.contains(newWord)) &#123; //new word is a valid word if (level.contains(newWord)) &#123; //shortest ladder found generateLadder(rSolve, current, newWord, ladder, side); return; &#125; current.push(newWord); //Add the valid word to the current stack solve.enqueue(current); //Add the stack back into the back of the queue current.pop(); //Remove the word from the stack &#125; &#125;&#125;string game(const Set&lt;string&gt; &amp;dic, const string &amp;from, const string &amp;to) &#123; Queue&lt;Stack&lt;string&gt;&gt; solveFrom; //Stores the information for the word 1 side Queue&lt;Stack&lt;string&gt;&gt; solveTo; //Stores the information for the word 2 side Set&lt;string&gt; fromLevel = &#123;to&#125;, toLevel = &#123;from&#125;; //Stores the words visited by each side string ladder = \"\"; //The result string to return solveFrom.add(&#123;to&#125;); //Initialize solveTo.add(&#123;from&#125;); //Initialize while(!solveFrom.isEmpty() &amp;&amp; !solveTo.isEmpty())&#123; //Search from word 1 side BFS(dic, solveFrom, solveTo, fromLevel, toLevel, ladder, true); if(ladder != \"\") return ladder; //Ladder found //Search from word 2 side BFS(dic, solveTo, solveFrom, toLevel, fromLevel, ladder, false); if(ladder != \"\") return ladder; //Ladder found &#125; return \"NA\";&#125;void interact() &#123; ifstream infile; promptUserForFile(infile, \"Dictionary file name: \"); Set&lt;string&gt; dict; string dictWord; while(getline(infile, dictWord)) &#123; dict.add(dictWord); &#125; infile.close(); while (1) &#123; string fromWord, toWord; cout &lt;&lt; endl; fromWord = getLine(\"Word 1 (or Enter to quit): \"); if (fromWord == \"\") break; transform(fromWord.begin(), fromWord.end(), fromWord.begin(), ::tolower); toWord = getLine(\"Word 2 (or Enter to quit): \"); if (toWord == \"\") break; transform(toWord.begin(), toWord.end(), toWord.begin(), ::tolower); if (dictCheck(dict, fromWord, toWord)) &#123; cout &lt;&lt; \"The two words must be found in the dictionary, or one step from a dictionary word.\" &lt;&lt; endl; continue; &#125; else if (wordCheck(fromWord, toWord)) &#123; cout &lt;&lt; \"The two words must be different.\" &lt;&lt; endl; continue; &#125; else &#123; string gameResult = game(dict, fromWord, toWord); if (gameResult == \"NA\") &#123; cout &lt;&lt; \"No word ladder found from \" &lt;&lt; toWord &lt;&lt; \" back to \" &lt;&lt; fromWord &lt;&lt; \".\" &lt;&lt; endl; &#125; else &#123; //cout &lt;&lt; \"Step 1 Done\" &lt;&lt; endl; cout &lt;&lt; \"A ladder from \" &lt;&lt; toWord &lt;&lt; \" back to \" &lt;&lt; fromWord &lt;&lt; \":\" &lt;&lt; endl; cout &lt;&lt; gameResult &lt;&lt; endl; &#125; &#125; &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://samuelpeng.com/blog/categories/Programming/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://samuelpeng.com/blog/tags/C/"},{"name":"BFS","slug":"BFS","permalink":"http://samuelpeng.com/blog/tags/BFS/"},{"name":"Classic","slug":"Classic","permalink":"http://samuelpeng.com/blog/tags/Classic/"},{"name":"Stanford","slug":"Stanford","permalink":"http://samuelpeng.com/blog/tags/Stanford/"}]}]}