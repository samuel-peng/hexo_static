{"meta":{"title":"Samuel Peng","subtitle":"Programming Log","description":null,"author":"Samuel Peng","url":"http://samuelpeng.com/blog"},"pages":[{"title":"About Me","date":"2018-07-07T07:54:46.000Z","updated":"2018-07-07T04:57:58.327Z","comments":true,"path":"about/index.html","permalink":"http://samuelpeng.com/blog/about/index.html","excerpt":"","text":"I’m Samuel Peng, and I am a…Programmer.I am interested in &amp; work with: C++ Swift JavaScript Python Java I’ve been involved in: Hackathons iOS Development Web Development More… Singer-SongwriterVisit my website @ joelsparksmusic.com to learn more about the music I make. Neflix LoverI love watching… Grey’s Anatomy Scandal Criminal Minds Person of Interest Sherlock House of Cards … Contact me? Telegram: @sjpeng GitHub: samuel-peng Twitter: @samueljpeng Email: samuelpeng1@gmail.com"}],"posts":[{"title":"Word Ladder","slug":"word-ladder","date":"2018-07-07T10:10:20.000Z","updated":"2018-07-07T05:45:46.122Z","comments":true,"path":"2018/07/07/word-ladder/","link":"","permalink":"http://samuelpeng.com/blog/2018/07/07/word-ladder/","excerpt":"","text":"You know it, the classic word ladder problem. It turns out to be part 1 of my second assignment at Stanford&nbsp;University.For those of you who don’t know about word ladder (I doubt there is any), here’s a condensed version of the problem description. Input: a dictionary file and two words.Objective: find a path to go from the first word to the second, by changing one letter each time.Output: the path from word 1 to word two. Simple enough. However, the problem requires the program not to use recursion but use BFS to accomplish such task. It’s a fairly easy problem, and the pseudocode was even given to us: to find a path from word 1 to word 2:&nbsp;&nbsp;&nbsp;&nbsp;create a queue of stacks, initially containing only a single stack storing {word 1}.&nbsp;&nbsp;&nbsp;&nbsp;loop until queue is empty (can’t find the path) or word 2 is found:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dequeue a stack s.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for each valid unused English word w that differs by 1 letter of the word on top of s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create a new stack s2 whose contents are s + w added on top&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add s2 to the queue However, there is a pretty serious issue to consider with this problem, and that is the size of the dictionary. The dictionary file contains nearly .27 million words in it. Although efficient data types will be used to handle them, the fact that there are so many possible “next words” for each word is frightening. The queue that stores the stacks builds up too quickly that the memory it needs can’t be ignored.With only a 5-letter word example that should take merely 9 steps to finish, I get an error message:A C++ exception occurred during program execution:std::bad_alloc\\nStack trace:vector.h Vector::operator=(Vector const&amp;)queue.h Queue::expandRingBufferCapacity()queue.h Queue::enqueue(Stack const&amp;)wordladder.cpp game(Set const&amp;, string, string)wordladder.cpp interact()wordladder.cpp main()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://samuelpeng.com/blog/categories/Programming/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://samuelpeng.com/blog/tags/C/"},{"name":"BFS","slug":"BFS","permalink":"http://samuelpeng.com/blog/tags/BFS/"},{"name":"Classic","slug":"Classic","permalink":"http://samuelpeng.com/blog/tags/Classic/"}]}]}